[ { "title": "[JAVA8_함수형 프로그래밍] String, Comparator 그리고 filter", "url": "/posts/Java8-String,Comparator-%EA%B7%B8%EB%A6%AC%EA%B3%A0-filter/", "categories": "Java8", "tags": "Java8, 함수형 프로그래밍, 람다, stream", "date": "2022-06-23 17:00:00 +0900", "snippet": "▶︎ 스트링 이터레이션 chars() 메서드는 forEach() 내부 이터레이터를 사용하여 이터레이션하는 스트림을 리턴한다.final String str = &quot;w00t&quot;;str.chars() .forEach(ch -&amp;gt; System.out.println(ch));// 메서드 레퍼런스로 변환str.chars() .forEach(System.out::println); 1194848116→ 문자가 출력되는 대신 숫자가 출력됐다. 그 이유는 chars() 메서드가 Characters의 스트림 대신 문자를 표현하는 intStream을 리턴했기 때문// chars() 메서드내부public default IntStream chars() { class CharIterator implements PrimitiveIterator.OfInt { int cur = 0; public boolean hasNext() { return cur &amp;lt; length(); } public int nextInt() { ... ... 컨비니언스 메소드를 사용한 int를 문자로 출력str.chars() .forEach(IterateString::printChar);private static void printChar(int aChar) { System.out.println((char)(aChar));} w00t 처음부터 int가 아닌 문자로 처리하고 싶다면 chars()를 호출하고 나서 바로 문자로 변환하면 된다.str.chars() .mapToObj(ch -&amp;gt; Character.valueOf((char) ch)) .forEach(System.out::println); 한번 스트림을 얻으면 스트림에서 제공하는 메서드를 이용하여 스트링에 있는 문자들을 처리할 수 있다. (map(), filter(), reduce() 등)// 숫자 필터링하기str.chars() .filter(ch -&amp;gt; Character.isDigit(ch)) .forEach(ch -&amp;gt; printChar(ch)); 00// 숫자 필터링하기의 메서드 레퍼런스 형식str.chars() .filter(Character::isDigit) .forEach(IterateString::printChar);→ 메서드 레퍼런스는 일반적인 파라미터 라우팅을 제거하도록 해준다.▶︎ Comparator 인터페이스 구현 Comparator을 사용한 정렬 → name, age 혹은 여러 필드의 조합으로 엘리먼트를 비교하고 싶을때 Comparator 인터페이스로 가능 // person.javapublic class Person { private final String name; private final int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } public int ageDifference(final Person other) { return age - other.age; } public String toString() { return String.format(&quot;%s - %d&quot;, name, age); }}// 작업할 사람들의 이름과 나이를 생성final List&amp;lt;Person&amp;gt; people = Arrays.asList( new Person(&quot;John&quot;, 20), new Person(&quot;Sara&quot;, 21), new Person(&quot;Jane&quot;, 21), new Person(&quot;Greg&quot;, 35)); age 오름차순 정렬List&amp;lt;Person&amp;gt; ascendingAge = people.stream() .sorted((person1, person2) -&amp;gt; person1.ageDifference(person2)) .collect(Collectors.toList());printPeople(&quot;Sorted in ascending order by age : &quot;, ascendingAge); Sorted in ascending order by age : John - 20Sara - 21Jane - 21Greg - 35→ 리스트에 대한 sort()메서드는 void메서드이기 때문에 리스트 자체가 변경될수 있음. 스트림에서 sorted()메서드는 이미 갖고 있는 컬렉션을 변경하는 대신 정렬된 컬렉션을 리턴함// 메서드 레퍼런스로 변환List&amp;lt;Person&amp;gt; ascendingAge2 = people.stream() .sorted(Person::ageDifference) .collect(Collectors.toList());*Stream*&amp;lt;T&amp;gt; sorted(*Comparator*&amp;lt;? *super* T&amp;gt; comparator);→ sorted 메서드는 파라미터로 Comparator를 갖는다. Comparator가 함수형 인터페이스이기 때문에 람다 표현식을 인수로 쉽게 넘길 수 있다.collect()→ 이터레이션의 타깃 멤버를 원하는 타입의 포맷으로 변환하는 리듀서(reducer) age 내림차순 정렬// age내림차순// 파라미터의 순서만 바꾸면되지만 중복코드가 된다List&amp;lt;Person&amp;gt; descendingAge = people.stream() .sorted((person1, person2) -&amp;gt; person2.ageDifference(person1)) .collect(Collectors.toList());printPeople(&quot;Sorted in descending order by age : &quot;, descendingAge);System.out.println(&quot;=========================&quot;);// reversed()메소드로 중복제거Comparator&amp;lt;Person&amp;gt; compareAscending = (person1, person2) -&amp;gt; person1.ageDifference(person2);Comparator&amp;lt;Person&amp;gt; compareDescending = compareAscending.reversed();printPeople(&quot;Sorted in ascending order by age : &quot; , people.stream() .sorted(compareAscending) .collect(Collectors.toList()));printPeople(&quot;Sorted in descending order by age : &quot; , people.stream() .sorted(compareDescending) .collect(Collectors.toList()));→ 위 소스는 람다 표현식이 아닌 메서드 레퍼런스로는 쉽게 변경할 수 없다. 왜냐하면 파라미터 순서가 메서드 레퍼런스를 사용하기 위한 파라미터 라우팅 규칙을 따르지 않기 때문! Sorted in descending order by age :Greg - 35Sara - 21Jane - 21John - 20Sorted in ascending order by age :John - 20Sara - 21Jane - 21Greg - 35 name 알파벳의 오름차순 정렬printPeople(&quot;Sorted in ascending order by name : &quot; , people.stream() .sorted((person1, person2) -&amp;gt; person1.getName().compareTo(person2.getName())) .collect(Collectors.toList())); Sorted in ascending order by name :Greg - 35Jane - 21John - 20Sara - 21 가장 젊은 사람, 가장 늙은 사람 출력// 가장 젊은 사람people.stream() .min(Person::ageDifference) .ifPresent(youngest -&amp;gt; System.out.println(&quot;Youngest : &quot; + youngest));// 가장 나이가 많은 사람people.stream() .max(Person::ageDifference) .ifPresent(eldest -&amp;gt; System.out.println(&quot;eldest : &quot; + eldest));→ min, max 메서드는 Optional을 리턴한다. 왜냐하면 리스트가 비어 있을 수 있고 따라서 가장 어린사람, 나이많은 사람이 없을 수 있기 때문에▶︎ 여러가지 비교연산 comparing() 메서드// 이름으로 사람 정렬하기 Function 이용final Function&amp;lt;Person, String&amp;gt; byName = person -&amp;gt; person.getName();printPeople(&quot;이름순 정렬하기 : &quot;,people.stream() .sorted(Comparator.comparing(byName)) .collect(Collectors.toList())); 이름순 정렬하기 : Greg - 35Jane - 21John - 20Sara - 21 복합정렬// 나이, 이름으로 복합 정렬 (나이 -&amp;gt; 이름)final Function&amp;lt;Person, Integer&amp;gt; byAge = person -&amp;gt; person.getAge();final Function&amp;lt;Person, String&amp;gt; byTheirName = person -&amp;gt; person.getName();printPeople(&quot;복합 정렬하기 : &quot;, people.stream() .sorted(Comparator.comparing(byAge).thenComparing(byTheirName)) .collect(Collectors.toList())); 복합 정렬하기 :John - 20Jane - 21Sara - 21Greg - 35▶︎ collect 메서드와 Collectors 클래스 사용하기 원본 리스트에서 20살 이상의 사람들만 출력하기 가변성과 forEach()를 사용한 버전List&amp;lt;Person&amp;gt; olderThan20 = new ArrayList&amp;lt;&amp;gt;();people.stream() .filter(person -&amp;gt; person.getAge() &amp;gt; 20) .forEach(person -&amp;gt; olderThan20.add(person));System.out.println(&quot;olderThan20 = &quot; + olderThan20);→ 타깃 컬렉션 (olderThan20)에 엘리먼트를 추가하는 오퍼레이션이 너무 로우레벨이다. 이터레이션을 동시에 실행하려면, 즉시 스레드 세이프티 문제에 대해 고려해야함. collect() 메서드 사용한 버전List&amp;lt;Person&amp;gt; olderThan20 = people.stream() .filter(person -&amp;gt; person.getAge() &amp;gt; 20) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);-첫 번째 파라미터 : 결과 컨테이너 만들기 (팩토리(factory)나 서플라이어(supplier))-두 번째 파라미터 : 하나의 엘리먼트를 결과 컨테이너에 추가하는 방법-세 번째 파라미터 : 하나의 결과 컨테이너를 다른 것과 합치는 방법 collect() 메서드를 사용함으로써 코드에서 명시적 변경이 발생하지 않기 때문에 이터레이션의 실행을 병렬화하기가 쉽다. 변경에 대한 부분은 라이브러리에서 제어하기 때문에 라이브러리를 사용한 조율이 간단하고 스레드 세이프티를 보장해준다. collect() 메서드는 다른 서브 리스트 간의 병렬 덧셈을 수행하여 그 병렬 덧셈의 결과를 스레드 세이프티하게 좀 더 큰 규모의 리스트로 합칠 수 있다. Collectors 유틸리티 클래스List&amp;lt;Person&amp;gt; orderThan20_3 = people.stream() .filter(person -&amp;gt; person.getAge() &amp;gt; 20) .collect(toList());→ 추가적으로 세트를 모으는 toSet(), key-value 컬렉션을 모으는 toMap()도 있음. mapping(), colectingAndThen(), minBy(), maxBy(), groupingBy()과 같은 메서드를 사용하여 여러 오퍼레이션을 합쳐서 사용할 수도 있다. 나이로 groupingBy()//Collectors 유틸리티 클래스 응용 - groupingBy()Map&amp;lt;Integer, List&amp;lt;Person&amp;gt;&amp;gt; peopleByAge = people.stream() .collect(groupingBy(Person::getAge));System.out.println(&quot;Grouping by age : &quot; + peopleByAge); Grouping by age : {35=[Greg - 35], 20=[John - 20], 21=[Sara - 21, Jane - 21]} 이름과 나이 순서대로 정렬Map&amp;lt;Integer, List&amp;lt;String&amp;gt;&amp;gt; nameOfPeopleByAge = people.stream() .collect(groupingBy(Person::getAge, mapping(Person::getName, toList())));System.out.println(&quot;People grouped by age : &quot; + nameOfPeopleByAge); People grouped by age : {35=[Greg], 20=[John], 21=[Sara, Jane]}// groupingBy 메서드 내부Collector&amp;lt;T, ?, Map&amp;lt;K, D&amp;gt;&amp;gt; groupingBy(Function&amp;lt;? super T, ? extends K&amp;gt; classifier, Collector&amp;lt;? super T, A, D&amp;gt; downstream) { return groupingBy(classifier, HashMap::new, downstream);}→ 첫 번째 인자는 그룹을 만드는 기준(나이)이고, 두 번째는 mapping() 함수 호출의 결과인 Collector 첫 번째 문자로 이름을 그룹핑하고 각 그룹의 나이가 많은 사람을 찾기Comparator&amp;lt;Person&amp;gt; byAge = Comparator.comparing(Person::getAge);Map&amp;lt;Character, Optional&amp;lt;Person&amp;gt;&amp;gt; oldestPersonOfEachLetter = people.stream() .collect(groupingBy(person -&amp;gt; person.getName().charAt(0), reducing(BinaryOperator.maxBy(byAge))));System.out.println(&quot;Oldest person of each letter : &quot;);System.out.println(oldestPersonOfEachLetter); Oldest person of each letter :{S=Optional[Sara - 21], G=Optional[Greg - 35], J=Optional[Jane - 21]}[출처][자바 8 람다의 힘(벤컷 수브라마니암 지음, 루비페이퍼, 2014)]" }, { "title": "[JAVA8_함수형 프로그래밍] 컬렉션의 사용", "url": "/posts/Java8-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%98-%EC%82%AC%EC%9A%A9/", "categories": "Java8", "tags": "Java8, 함수형 프로그래밍, 람다, stream", "date": "2022-06-06 12:40:00 +0900", "snippet": "▶︎ 리스트를 사용한 이터레이션final List&amp;lt;String&amp;gt; friends = Arrays.asList(&quot;Brian&quot;, &quot;Nate&quot;, &quot;Neal&quot;, &quot;Raju&quot;, &quot;Sara&quot;, &quot;Scott&quot;); 기존 관습적인 방법// 1번for (int i = 0; i &amp;lt; friends.size(); i++) { System.out.println(friends.get(i));}// 2번for (String name : friends) { System.out.println(&quot;name = &quot; + name);} 함수형 스타일// 어노니머스 이너클래스 (Anonymous Inner Class)friends.forEach(new Consumer&amp;lt;String&amp;gt;() { @Override public void accept(String name) { System.out.println(&quot;name = &quot; + name); }});// 람다 표현식 1friends.forEach((final String name) -&amp;gt; System.out.println(&quot;name = &quot; + name));// 람다 표현식 2friends.forEach((name) -&amp;gt; System.out.println(&quot;name = &quot; + name));// 람다 표현식 3friends.forEach(name -&amp;gt; System.out.println(&quot;name = &quot; + name));// 람다 표현식 4 (메서드 레퍼런스)friends.forEach(System.out::println);▶︎ 리스트 변형final List&amp;lt;String&amp;gt; friends = Arrays.asList(&quot;Brian&quot;, &quot;Nate&quot;, &quot;Neal&quot;, &quot;Raju&quot;, &quot;Sara&quot;, &quot;Scott&quot;); 기존 관습적인 방법ArrayList&amp;lt;String&amp;gt; uppercaseNames = new ArrayList&amp;lt;&amp;gt;();for (String name : friends) { uppercaseNames.add(name.toUpperCase());} 내부 이터레이션 사용ArrayList&amp;lt;String&amp;gt; uppercaseNames = new ArrayList&amp;lt;&amp;gt;();friends.forEach(name -&amp;gt; uppercaseNames.add(name.toUpperCase()));System.out.println(&quot;uppercaseNames = &quot; + uppercaseNames); 람다 표현식의 사용friends.stream() .map(name -&amp;gt; name.toUpperCase()) .forEach(name -&amp;gt; System.out.print(name + &quot; &quot;));System.out.println();// 입력/출력의 엘리먼트 타입이 달라도 됨friends.stream() .map(name -&amp;gt; name.length()) .forEach(count -&amp;gt; System.out.print(count + &quot; &quot;));System.out.println();// 메서드 레퍼런스의 사용friends.stream() .map(String::toUpperCase) .forEach(System.out::println);▶︎ 엘리먼트 찾기 - filter() 메서드final List&amp;lt;String&amp;gt; friends = Arrays.asList(&quot;Brian&quot;, &quot;Nate&quot;, &quot;Neal&quot;, &quot;Raju&quot;, &quot;Sara&quot;, &quot;Scott&quot;); 기존 방법final List&amp;lt;String&amp;gt; startsWithN = new ArrayList&amp;lt;&amp;gt;();for (String name : friends) { if(name.startsWith(&quot;N&quot;)){ startsWithN.add(name); }} 개선 방법final List&amp;lt;String&amp;gt; startsWithN = friends.stream() .filter(name -&amp;gt; name.startsWith(&quot;N&quot;)) .collect(Collectors.toList());System.out.println(String.format(&quot;Found %d names&quot;, startsWithN.size()));▶︎ 람다 표현식의 재사용성final List&amp;lt;String&amp;gt; friends = Arrays.asList(&quot;Brian&quot;, &quot;Nate&quot;, &quot;Neal&quot;, &quot;Raju&quot;, &quot;Sara&quot;, &quot;Scott&quot;);final List&amp;lt;String&amp;gt; editors = Arrays.asList(&quot;Brian&quot;, &quot;Jackie&quot;, &quot;John&quot;, &quot;Mike&quot;);final List&amp;lt;String&amp;gt; comrades = Arrays.asList(&quot;Kate&quot;, &quot;Ken&quot;, &quot;Nick&quot;, &quot;Paula&quot;, &quot;Zach&quot;); 중복 코드 발생final long countFriendsStartN = friends.stream() .filter(name -&amp;gt; name.startsWith(&quot;N&quot;)).count();final long countEditorsStartN = editors.stream() .filter(name -&amp;gt; name.startsWith(&quot;N&quot;)).count();final long countComradesStartN = comrades.stream() .filter(name -&amp;gt; name.startsWith(&quot;N&quot;)).count(); 중복 코드 개선 - Predicate 타입 사용final Predicate&amp;lt;String&amp;gt; startWithN = name -&amp;gt; name.startsWith(&quot;N&quot;);final long countFriendsStartN = friends.stream() .filter(startWithN).count();final long countEditorsStartN = editors.stream() .filter(startWithN).count();final long countComradesStartN = comrades.stream() .filter(startWithN).count();▶︎ 렉시컬 스코프와 클로저 사용하기final List&amp;lt;String&amp;gt; friends = Arrays.asList(&quot;Brian&quot;, &quot;Nate&quot;, &quot;Neal&quot;, &quot;Raju&quot;, &quot;Sara&quot;, &quot;Scott&quot;);final List&amp;lt;String&amp;gt; editors = Arrays.asList(&quot;Brian&quot;, &quot;Jackie&quot;, &quot;John&quot;, &quot;Mike&quot;);final List&amp;lt;String&amp;gt; comrades = Arrays.asList(&quot;Kate&quot;, &quot;Ken&quot;, &quot;Nick&quot;, &quot;Paula&quot;, &quot;Zach&quot;); 람다표현식에서의 중복final Predicate&amp;lt;String&amp;gt; startWithN = name -&amp;gt; name.startsWith(&quot;N&quot;);final Predicate&amp;lt;String&amp;gt; startWithB = name -&amp;gt; name.startsWith(&quot;B&quot;);final long countFriendsStartN = friends.stream() .filter(startWithN).count();final long countFriendsStartB = friends.stream() .filter(startWithB).count(); 렉시컬 스코프로 중복제거하기 렉시컬 스코프 : 사용한 하나의 컨텍스트에서 제공한 값을 캐시해 두었다가 나중에 다른 컨텍스트에서 사용하는 기술 final long countFriendsStartN2 = friends.stream() .filter(checkIfStartWith(&quot;N&quot;)).count();final long countFriendsStartB2 = friends.stream() .filter(checkIfStartWith(&quot;B&quot;)).count();public static Predicate&amp;lt;String&amp;gt; checkIfStartWith(final String letter) { return name -&amp;gt; name.startsWith(letter);} 적용 범위를 좁히기 위한 리팩토링 - Function&amp;lt;T,R&amp;gt; 인터페이스// 1번final Function&amp;lt;String, Predicate&amp;lt;String&amp;gt;&amp;gt; startsWithLetter = (String letter) -&amp;gt; { Predicate&amp;lt;String&amp;gt; checkStarts = (String name) -&amp;gt; name.startsWith(letter); return checkStarts;};// 2번final Function&amp;lt;String, Predicate&amp;lt;String&amp;gt;&amp;gt; startsWithLetter = (String letter) -&amp;gt; (String name) -&amp;gt; name.startsWith(letter);// 3번final Function&amp;lt;String, Predicate&amp;lt;String&amp;gt;&amp;gt; startsWithLetter = letter -&amp;gt; name -&amp;gt; name.startsWith(letter);// apply로 적용final long countFriendsStartN3 = friends.stream() .filter(startsWithLetter.apply(&quot;N&quot;)).count();final long countFriendsStartB3 = friends.stream() .filter(startsWithLetter.apply(&quot;B&quot;)).count();▶︎ 엘리먼트 선택 기존 관습적인 방법public static void pickName (final List&amp;lt;String&amp;gt; names, final String startingLetter) { String foundName = null; for (String name : names) { if (name.startsWith(startingLetter)) { foundName = name; break; } } System.out.print(String.format(&quot;A name starting with %s: &quot;, startingLetter)); if (foundName != null) { System.out.println(foundName); } else { System.out.println(&quot;No name found&quot;); }}→ null 체크가 필수적임 람다 표현식public static void pickName (final List&amp;lt;String&amp;gt; names, final String startingLetter) { final Optional&amp;lt;String&amp;gt; foundName = names.stream() .filter(name -&amp;gt; name.startsWith(startingLetter)) .findFirst(); System.out.println(String.format(&quot;A name starting with %s: %s&quot;, startingLetter, foundName.orElse(&quot;No name found&quot;))); foundName.ifPresent(name -&amp;gt; System.out.println(&quot;name = &quot; + name));} Optional 클래스는 결과가 없는 경우에 유용. NullPointerException을 막아주고 “결과가 없다”라는 것을 가능한 출력해서 사용자에게 명확하게 알려줌 isPresent, ifPresent 조합으로 객체가 존재하는지 확인가능▶︎ 컬렉션을 하나의 값으로 리듀스final List&amp;lt;String&amp;gt; friends = Arrays.asList(&quot;Brian&quot;, &quot;Nate&quot;, &quot;Neal&quot;, &quot;Raju&quot;, &quot;Sara&quot;, &quot;Scott&quot;); 컬렉션에 있는 문자의 전체 수를 계산하기System.out.println(&quot;Total number of characters in all names: &quot; + friends.stream() .mapToInt(name -&amp;gt; name.length()) .sum());→ sum() 메서드 외에도 max(), min(), sorted(), average() 등의 메서드도 사용가능 가장 긴 이름을 출력하기final Optional&amp;lt;String&amp;gt; aLongName = friends.stream() .reduce((name1, name2) -&amp;gt; name1.length() &amp;gt;= name2.length() ? name1 : name2);aLongName.ifPresent(name -&amp;gt; System.out.println(String.format(&quot;A longest name: %s&quot;, name)));▶︎ 엘리먼트 조인 기존 루프 방법for (int i = 0; i &amp;lt; friends.size() -1; i++) { System.out.print(friends.get(i) + &quot;, &quot;);}if (friends.size() &amp;gt; 0) System.out.println(friends.get(friends.size() - 1)); StringJoiner 클래스 사용System.out.println(String.join(&quot;, &quot;, friends));// collect() 컨비니언스 메서드로 변경된 엘리먼트 처리// 결과 : BRIAN, NATE, NEAL, RAJU, SARA, SCOTTSystem.out.println( friends.stream() .map(String::toUpperCase) .collect(Collectors.joining(&quot;, &quot;)));→ StringJoiner 클래스는 접두어, 접미어, 중간문자 설정 등 결합하는 포맷에 대한 많은 제어기능 제공[출처][자바 8 람다의 힘(벤컷 수브라마니암 지음, 루비페이퍼, 2014)]" }, { "title": "[JPA] 값 타입", "url": "/posts/JPA10/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2022-02-02 14:50:00 +0900", "snippet": "◼︎ 값 타입▶︎ JPA의 데이터 타입 분류 엔티티 타입 @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적 가능 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능 값 타입 int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경시 추적 불가 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체 ▶︎ 값 타입 분류 기본값 타입 자바 기본 타입 (int, double) 래퍼 클래스(Integer, Long) String 생명주기를 엔티티에 의존 (예. 회원을 삭제하면 이름, 나이 필드도 함께 삭제) 값 타입은 공유하면 안됨 (예. 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨) 기본 타입은 항상 값을 복사함 임베디드 타입(embedded type, 복합 값 타입) 새로운 값 타입을 직접 정의할 수 있음 JPA는 임베디드 타입(embedded type)이라 함 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입 컬렉션 값 타입(collection value type)▶︎ 임베디드 타입(embedded type, 복합 값 타입) 새로운 값 타입을 직접 정의할 수 있음 JPA는 임베디드 타입(embedded type)이라 함 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입 사용법• @Embeddable : 값 타입을 정의하는 곳에 표시 기본 생성자 필수• @Embedded : 값 타입을 사용하는 곳에 표시 • 기본 생성자 필수 임베디드 타입 장점• 재사용• 높은 응집도• Period.isWork()처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음• 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티 티에 생명주기를 의존함 임베디드 타입과 테이블 매핑 임베디드 타입은 엔티티의 값일 뿐이다. 임베디드 타입을 사용하기 전과 후의 매핑하는 테이블은 같다. 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음 한 엔티티에서 같은 값 타입을 사용하기 위해서는 @AttributeOverrides, @AttributeOverride를 사용해서 컬럼명 속성을 재정의▶︎ 값 타입과 불변 객체 값 타입의 공유 참조 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함 부작용(side effect) 발생 대신 값(인스턴스)를 복사해서 사용 객체 타입의 한계 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다. 자바 기본 타입에 값을 대입하면 값을 복사한다. 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다. 객체의 공유 참조는 피할 수 없다. //기본 타입 int a = 10; int b = a;//기본 타입은 값을 복사 b = 4; //객체 타입 Address a = new Address(“Old”); Address b = a; //객체 타입은 참조를 전달 b.setCity(“New”) 불변객체 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단 값 타입은 불변 객체(immutable object)로 설계해야함 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨 참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체 ▶︎ 값 타입 컬렉션 값 타입을 하나 이상 저장할 때 사용 @ElementCollection, @CollectionTable 사용 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다. 컬렉션을 저장하기 위한 별도의 테이블이 필요함 값 타입 컬렉션의 제약사항 값 타입은 엔티티와 다르게 식별자 개념이 없다. 값은 변경하면 추적이 어렵다. 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 함 : null 입력X, 중복 저장X 값 타입 컬렉션 대안 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용 (값 타입의 엔티티 승격고려) 영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬 렉션 처럼 사용 ▶︎ 엔티티와 값 타입 엔티티 타입 식별자O 생명주기관리 공유 값 타입 식별자X 생명 주기를 엔티티에 의존 공유하지 않는 것이 안전(복사해서 사용) 불변 객체로 만드는 것이 안전 값 타입은 정말 값 타입이라 판단될 때만 사용 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티로 승격시켜 사용해야함(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저) " }, { "title": "[JPA] 프록시와 연관관계 관리", "url": "/posts/JPA9/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2022-02-01 13:55:00 +0900", "snippet": "◼︎ 프록시▶︎ 프록시 기초 em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 조회)▶︎ 프록시 특징 실제 클래스를 상속 받아서 만들어짐 실제 클래스와 겉 모양이 같다. 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상) 프록시 객체는 실제 객체의 참조(target)를 보관 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출//프록시 객체 초기화 Member member = em.getReference(Member.class, “id1”); member.getName(); 프록시 객체는 처음 사용할 때 한번만 초기화 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초 기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비 교 실패, 대신 instance of 사용) 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해 도 실제 엔티티 반환 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생 (하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)◼︎ 즉시로딩과 지연로딩▶︎ 지연로딩@Entity public class Member { @Id @GeneratedValue private Long id;@Column(name = &quot;USERNAME&quot;)private String name;  @ManyToOne(fetch = FetchType.LAZY) // 지연로딩 LAZY를 사용해서 프록시로 조회  @JoinColumn(name = &quot;TEAM_ID&quot;)private Team team;..} 실제 team을 사용하는 시점에 초기화됨Team team = member.getTeam();team.getName();▶︎ 즉시로딩@Entity public class Member { @Id @GeneratedValue private Long id;@Column(name = &quot;USERNAME&quot;)private String name;  @ManyToOne(fetch = FetchType.LAZY) // 지연로딩 LAZY를 사용해서 프록시로 조회  @JoinColumn(name = &quot;TEAM_ID&quot;)private Team team;..} 즉시 로딩(EAGER), Member조회시 항상 Team도 조회▶︎ 프록시와 즉시로딩 주의 모든 연관관계에서 지연 로딩을 사용 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. @ManyToOne, @OneToOne은 기본이 즉시 로딩 -&amp;gt; LAZY로 설정 @OneToMany, @ManyToMany는 기본이 지연 로딩 JPQL fetch 조인이나, 엔티티 그래프 기능을 사용◼︎ 영속성 전이 CASCADE와 고아객체▶︎ 영속성 전이 CASCADE 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들도 싶을 때 예 : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.@OneToMany(mappedBy=&quot;parent&quot;, cascade=CascadeType.PERSIST) 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함 을 제공할 뿐 CASCADE의 종류- ALL: 모두 적용- PERSIST: 영속- REMOVE: 삭제- MERGE: 병합- REFRESH: REFRESH DETACH: DETACH▶︎ 고아객체 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티 를 자동으로 삭제 orphanRemoval = true Parent parent1 = em.find(Parent.class, id); parent1.getChildren().remove(0); //자식 엔티티를 컬렉션에서 제거 DELETE FROM CHILD WHERE ID=? 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능 참조하는 곳이 하나일 때 사용해야함 특정 엔티티가 개인소유할 때 사용 @OneToOne, @OneToMany만 가능 참고: 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.▶︎ 영속성 전이 + 고아 객체, 생명주기 CascadeType.ALL + orphanRemovel=true 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저) " }, { "title": "객체지향의 사실과 오해 2_타입과 추상화, 역할,책임,협력", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B42/", "categories": "책리뷰", "tags": "객체지향의 사실과 오해, 객체지향, 객체, 역할, 책임, 협력", "date": "2022-01-02 20:40:00 +0900", "snippet": "[출처][객체지향의 사실과 오해(조영호 지음, 위키북스, 2015)]◼︎ 타입과 추상화▶︎ 추상화 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것 모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것▶︎ 개념 공통점을 기반으로 객체들을 묶기 위한 그릇 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념 예) 거리를 누비는 교통수단은 ‘자동차’, 하늘을 나는 교통수단은 ‘비행기’ 등 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스 개념의 세 가지 관점 심볼 : 개념을 가리키는 간략한 이름이나 명칭 (예. 운송수단) 내연 : 개념의 의미 (예. 사람이 타고 이동 할 수 있는 것) 외연 : 개념에 속하는 객체들 (예. 자동차, 비행기, 배) ▶︎ 분류 객체에 특정한 개념을 적용하는 작업. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것 객체를 적절한 개념에 따라 분류한 애플리케이션은 유지보수가 용이하고 변경에 유연하게 대처할 수 있음▶︎ 타입 타입은 개념이다. 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다. 타입은 데이터가 어떻게 사용되느냐에 관한 것 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 데이터 타입 : 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.▶︎ 객체와 타입 어떤 객체가 어떤 타입에 속하는지를 경정하는 것은 객체가 수행하는 행동이다. 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다. 객체가 다른 객체와 동일한 데이터를 가지고 있더라도 다른 행동을 한다면 그 객체들은 서로 다른 타입으로 분류돼야 한다. 반대로 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 객체의 타입을 결정하는 것은 행동뿐이다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력 객체가 외부에 제공해야 하는 책임을 먼저 결정하고 그 책임을 수행하는 데 적합한 데이터를 나중에 결정한 후, 데이터를 책임을 수행하는 데 필요한 외부 인터페이스 뒤로 캡슐화해야 한다.▶︎ 타입의 계층- 일반화와 특수화 일반적인 타입은 특수한 타입에 비해 적인 수의 행동을 가지며 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다. 단, 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행 할 수 있어야 한다. 일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 더 큰 크기의 외연 집합을 가진다. 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가지지만 더 적은 크기의 외연 집합을 가진다.- 슈퍼타입과 서브타입 두 타입 간의 관계가 행동에 의해 결정된다는 점이 중요 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행위적 호환성을 만족시켜야 한다.▶︎ 정적 모델- 타입의 목적 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 너무 어렵기 때문 타입은 시간에 따라 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. 타입은 추상화다. 타입을 이용하면 객체의 동적인 특성을 추상화 할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화 할 수 있는 효과적인 방법인 것이다.- 동적모델과 정적모델 동적모델 : 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것 정적모델 : 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것 객체지향 애플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야한다. 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.◼︎ 역할, 책임, 협력 객체지향 설계의 전체적인 품질을 결정하는 것은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질이다.▶︎ 협력 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다. 요청을 받은 사람은 일을 처리한 후 요청한 사람에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 응답한다.▶︎ 책임 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다. “객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것” - 크레이크 라만 (2004)- 책임의 분류 협력에 참여하는 객체들은 목표를 달성하는 데 필요한 책임을 수행한다. 하는 것(doing) 객체를 생성하거나 계산을 하는 등의 스스로 하는 것 다른 객체의 행동을 시작시키는 것 다른 객체의 활동을 제어하고 조절하는 것 아는 것 (knowing) 개인적인 정보에 관해 아는 것 관련된 객체에 관해 아는 것 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 - 책임과 메시지 메시지 전송 : 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것 두 객체 간의 협력은 메시지를 통해 이루어짐 메시지를 전송함으로써 협력을 요청하는 개체를 송신자. 메시지를 받아 요청을 처리하는 객체를 수신자. 메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 방법 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로 시작 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.▶︎ 역할 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식 다만, 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정 예) 왕 -&amp;gt; 여왕, 증인1 -&amp;gt; 증인2 동일한 역할을 수행할 수 있다는 것은 해당 객체들이 협력 내에서 동일한 책임의 집합을 수행할 수 있다는 것을 의미 (동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 때문에 동일한 책임을 수행할 수 있다는 것!) 역할은 객체지향 설계의 단순성(simplicity), 유연성(flexibility), 재사용성(reusability)를 뒷받침하는 핵심 개념- 협력의 추상화 역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화 할 수 있다는 것 역할을 이용하면 협력을 추상화함으로써 단순화 할 수 있다. 예) 왕 - 검사 - 증인1 왕 - 검사 - 증인2 여왕 - 검사 - 증인2 -&amp;gt; “판사 - 검사 - 증인”이 참여하는 하나의 추상적인 협력으로 대체가능 역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자다. 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.▶︎ 객체의 모양을 결정하는 협력- 흔한오류 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다는 선입견. 물론 객체가 상태의 일부로 데이터를 포함하는 것은 사실이지만 데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이다. 실제로 중요한 것은 객체의 행동, 즉 책임이다. 객체지향이 클래스와 클래스 간의 관계를 표현하는 정적인 측면에 중점을 둔다는 선입견. 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체이며, 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 매커니즘이라는 사실을 기억해라. 객체지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것- 협력을 따라 흐르는 객체의 책임 협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것을 의미한다. 이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다. 협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 그 행동을 수행하는 데 필요한 데이터를 고민해야 한다. 협력과 책임의 집합이 결정 된 후 -&amp;gt; 클래스 구현, 데이터 등을 고민▶︎ 객체지향 설계 기법- 책임-주도 설계 (Responsibility-Driven Design) 객체지향 설계란 애플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정 객체지향 설계의 핵심은 올바른 책임을 올바른 객체에게 할당하는 것 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체를 구축 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중 시스템은 스스로 자신을 책임질 수 있을 정도로 충분히 자율적인 동시에 다른 객체와 우호적으로 협력할 수 있을 정도로 충분히 협조적인 객체들로 이뤄진 생태계를 구성- 디자인 패턴 책임-주도 설계는 객체의 역할, 책임, 협력을 고안하기 위한 방법과 절차를 제시한다면 디자인 패턴은 책임-주도 설계의 결과를 표현 패턴은 특정한 상황에서 설계를 돕기 위해 모방하고 수정할 수 있는 과거의 설계 경험- 테스트-주도 개발 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것 테스트-주도 개발은 책임-주도 설계를 통해 도달해야 하는 목적지를 테스트라는 안전장치를 통해 좀 더 빠르고 견고한 방법으로 도달할 수 있도록 해주는 최상의 설계 프랙티스" }, { "title": "HTTP 웹 기본지식", "url": "/posts/HTTP/", "categories": "Web", "tags": "http, ip, tcp, udp, dns, get, post, put, delete", "date": "2021-12-27 14:30:00 +0900", "snippet": "◼︎ HTTP 웹 기본지식웹 기본 지식에 대해서는 대학교때 배웠던 내용이라 당연히 다 안다고 생각했었다.. 하지만 막상 면접에서 기본적인 질문이 들어왔을때 머릿속에만 맴도는 찝찝한 기분이 들어서… 이번에 다시한번 기초적인 것들이지만 정리해보고자 한다.▶︎ IP (인터넷 프로토콜) 지정한 IP 주소(IP Address)에 데이터 전달 패킷(Packet)이라는 통신 단위로 데이터 전달 비연결성 - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송 비신뢰성 - 패킷소실, 패킷의 순서보장X 프로그램 구분 - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션 구분불가▶︎ TCP (전송 제어 프로토콜, Transmission Control Protocol) 연결지향 - TCP 3 way handshake (가상 연결) 데이터 전달 보증 순서 보장 신뢰할 수 있는 프로토콜 현재는 대부분 TCP 사용▶︎ UDP (사용자 데이터그램 프로토콜, User Datagram Protocol) 기능 거의 없음 연결지향 X 데이터 전달 보증 X 순서 보장 X 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름▶︎ PORT 같은 IP내 애플리케이션 구분가능 0 ~ 65535 할당 가능 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음 FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443 ▶︎ DNS (도메인 네임 시스템, Domain Name System) 도메인 명을 IP 주소로 변환▶︎ URI (Uniform Resource Identifier) “URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있다” URI = URL + URN Uniform: 리소스 식별하는 통일된 방식 Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음) Identifier: 다른 항목과 구분하는데 필요한 정보 URL: Uniform Resource Locator URN: Uniform Resource Name ▶︎ URL scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443/search?q=hello&amp;amp;hl=ko 스키마(https) • 주로 프로토콜 사용 • 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 예) http, https, ftp 등등 • http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능 • https는 http에 보안 추가 (HTTP Secure) 호스트명(www.google.com) • 호스트명 • 도메인명 또는 IP 주소를 직접 사용가능 포트 번호(443) • 포트(PORT) • 접속 포트 • 일반적으로 생략, 생략시 http는 80, https는 443 패스(/search) • 리소스 경로(path), 계층적 구조 • 예) • /home/file1.jpg • /members • /members/100, /items/iphone12 쿼리 파라미터(q=hello&amp;amp;hl=ko) • key=value 형태 • ?로 시작, &amp;amp;로 추가 가능 ?keyA=valueA&amp;amp;keyB=valueB • query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태 fragment • https://docs.spring.io/spring-boot/docs/current/reference/html/gettingstarted.html#getting-started-introducing-spring-boot • html 내부 북마크 등에 사용 • 서버에 전송하는 정보 아님 ▶︎ HTTP 메시지 전송흐름▶︎ HTTP (HyperText Transfer Protocol) HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 거의 모든 형태의 데이터 전송 가능 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용- HTTP 역사 HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 RFC2068 (1997) -&amp;gt; RFC2616 (1999) -&amp;gt; RFC7230~7235 (2014) HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선- 기반 프로토콜 TCP: HTTP/1.1, HTTP/2 UDP: HTTP/3 현재 HTTP/1.1 주로 사용 • HTTP/2, HTTP/3 도 점점 증가- 클라이언트 서버 구조 Request Response 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기 서버가 요청에 대한 결과를 만들어서 응답- 무상태 프로토콜 - 스테이스리스(Stateless) 서버가 클라이언트의 상태를 보존X 장점: 서버 확장성 높음(스케일 아웃) 단점: 클라이언트가 추가 데이터 전송- 비 연결성 HTTP는 기본이 연결을 유지하지 않는 모델 일반적으로 초 단위의 이하의 빠른 속도로 응답 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다. 서버 자원을 매우 효율적으로 사용할 수 있음 TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등등 수 많은 자원이 함께 다운로드 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 HTTP/2, HTTP/3에서 더 많은 최적화▶︎ HTTP 메시지 요청 메시지 HTTP 메서드 (GET, POST, PUT, DELETE 등) - 서버가 수행해야 할 동작 지정 요청 대상 (/search?q=hello&amp;amp;hl=ko) HTTP Version 응답 메시지 HTTP 버전 HTTP 상태 코드: 요청 성공, 실패를 나타냄 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글 HTTP 헤더 HTTP 전송에 필요한 모든 부가정보 • 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보… HTTP 메시지 바디 실제 전송할 데이터 HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능 ▶︎ HTTP 메서드- GET: 리소스 조회 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음- POST: 요청 데이터 처리, 주로 등록에 사용 메시지 바디를 통해 서버로 요청 데이터 전달 서버는 요청 데이터를 처리 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다. 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용- PUT: 리소스를 대체, 해당 리소스가 없으면 생성 리소스를 대체 리소스가 있으면 대체 리소스가 없으면 생성 덮어쓰기 클라이언트가 리소스를 식별, 클라이언트가 리소스 위치를 알고 URI 지정 POST와 차이점 - PATCH: 리소스 부분 변경- DELETE: 리소스 삭제- HTTP 메서드의 속성 안전(Safe Methods) - 호출해도 리소스를 변경하지 않음. (GET 등) 멱등(Idempotent Methods) - 몇 번을 호출해도 결과가 같음. (GET, PUT, DELETE 등) GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다. PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다. DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다. POST: 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다. 캐시가능(Cacheable Methods) 응답 결과 리소스를 캐시해서 사용해도 되는가? GET, HEAD, POST, PATCH 캐시가능 실제로는 GET, HEAD 정도만 캐시로 사용 - HTTP 메서드 사용 URI 설계 문서(document) 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row) 예) /members/100, /files/star.jpg 컬렉션(collection) 서버가 관리하는 리소스 디렉터리 서버가 리소스의 URI를 생성하고 관리 예) /members 스토어(store) 클라이언트가 관리하는 자원 저장소 클라이언트가 리소스의 URI를 알고 관리 예) /files 컨트롤러(controller), 컨트롤 URI 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행 동사를 직접 사용 예) /members/{id}/delete ▶︎ HTTP 상태코드- 1xx (Informational): 요청이 수신되어 처리중- 2xx (Successful): 요청 정상 처리 200 OK 201 Created : 요청 성공해서 새로운 리소스가 생성됨 202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았음 배치 처리 같은 곳에서 사용 예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함 204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음 예) 웹 문서 편집기에서 save 버튼 save 버튼의 결과로 아무 내용이 없어도 된다. save 버튼을 눌러도 같은 화면을 유지해야 한다. 결과 내용이 없어도 204 메시지(2xx)만으로 성공을 인식할 수 있다. - 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요 리다이렉션 : 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동 (리다이렉트) 종류 * 300 Multiple Choices * 301 Moved Permanently * 302 Found* 303 See Other* 304 Not Modified* 307 Temporary Redirect * 308 Permanent Redirect 영구 리다이렉션 (301, 308) 리소스의 URI가 영구적으로 이동 원래의 URL를 사용X, 검색 엔진 등에서도 변경 인지 301 Moved Permanently 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 308 Permanent Redirect 301과 기능은 같음 리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST 유지) 일시적인 리다이렉션 (302, 307, 303) 리소스의 URI가 일시적으로 변경 따라서 검색 엔진 등에서 URL을 변경하면 안됨 302 Found 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 307 Temporary Redirect 302와 기능은 같음 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다. MUST NOT) 303 See Other 302와 기능은 같음 리다이렉트시 요청 메서드가 GET으로 변경 Post/Redirect/Get 사용예시• POST로 주문후에 새로 고침으로 인한 중복 주문 방지 • POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트 • 새로고침해도 결과 화면을 GET으로 조회• 중복 주문 대신에 결과 화면만 GET으로 다시 요청 기타 리다이렉션 (300, 304) 300 Multiple Choices : 사용안함 304 Not Modified 캐시를 목적으로 사용 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.) 304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로) 조건부 GET, HEAD 요청시 사용 - 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음 400 Bad Request : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음 401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요함 인증(Authentication) 되지 않음 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명 403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우 404 Not Found : 요청 리소스를 찾을 수 없음 요청 리소스가 서버에 없음 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때 - 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함 500 Internal Server Error : 서버 문제로 오류 발생, 애매하면 500 오류 503 Service Unavailable : 서비스 이용 불가 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음 Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음 [참고자료] 인프런) 모든 개발자를 위한 HTTP 웹 기본 지식 - 김영한 님 강의 참고" }, { "title": "객체지향의 사실과 오해 1_협력하는 객체들의 공동체, 객체의 행동과 상태 그리고 식별자", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B41/", "categories": "책리뷰", "tags": "객체지향의 사실과 오해, 객체지향, 객체", "date": "2021-11-26 16:40:00 +0900", "snippet": "[출처][객체지향의 사실과 오해(조영호 지음, 위키북스, 2015)]협력하는 객체들의 공동체 객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 ‘캡슐화’하는 소프트웨어 객체의 ‘자율성’을 설명하는데 효과적 현실 세계의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 협력하며 목표를 달성해 나가는 과정은 ‘메시지’를 주고받으며 공동의 목표를 달성하기 위해 ‘협력’하는 객체들의 관계를 설명하는데 적합커피 주문을 통해 바라본 역할, 책임, 협력 카페에서 손님이 주문한 커피를 제조하기 위해 캐시어와 바리스타가 협력하는 과정 속에는 ‘손님’, ‘계산원’, ‘바리스타’라는 역할이 존재 역할이라는 단어는 의미적으로 책임이라는 개념을 내포. 손님에게는 커피를 주문할 책임이, 계산원에게는 주문 내용을 바리스타에게 전달할 책임과 커피가 준비됐다는 사실을 손님에게 알릴 책임, 바리스타는 커피를 제조할 책임 존재 협력을 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행한다. 협력에 참여하는 각 개인은 책임을 수행하기 위해 다른 사람들에게 도움을 요청하기도 하며, 이를 통해 연쇄적인 요청과 응답으로 구성되는 협력 관계가 완성됨객체의 역할의 특징 여러 객체가 동일한 역할을 수행가능(손님 입장에서는 커피를 마실 수만 있다면 어떤 캐시어가 주문을 받는지는 중요하지 않음) 역할은 대체 가능성을 의미 (손님 입장에서 캐시어는 대체 가능) 각 객체는 책임을 수행하는 방법을 자율적으로 선택가능 (주문받는 방법, 커피를 만드는 방법 등)-&amp;gt; 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력 : 다형성(Polymorphism) 하나의 객체가 동시에 여러 역할을 수행가능객체지향의 본질 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 정해는 역할을 수행하며 역할은 관련된 책임의 집합이다. 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서디를 자율적으로 선택한다.객체의 상태와 행동 그리고 식별자객체 식별 가능한 개체 또는 사물 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.상태 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분가능행동 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동 행동의 결과로 객체 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 함식별자 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티 값은 식별자를 가지지않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야함 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있음상태와 행동, 식별자의 관계 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없다. 자율적인 객체는 스스로 자신의 상태를 책임져야한다. -&amp;gt; 행동을 통하여 다른 객체로 하여금 간접적으로 객체의 상태를 변경하는 것을 가능하게 한다. 객체지향의 기본 사상은 상태와 상태를 조작하기 위한 행동을 하나의 단위로 묶는 것 객체의 행동은 상태에 영향을 받고 상태를 변경시킨다. -&amp;gt; 객체 자신의 상태를 변경하거나 행동 내에서 협력하는 다른 객체에 대한 메시지를 전송한다. 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.상태를 먼저 결정하고 행동을 나중에 결정했을때의 문제점 캡슐화 저해 -&amp;gt; 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되어버릴 확률이 높아짐 객체를 협력자가 아닌 고립된 섬으로 만듬 객체의 재사용성 저하-&amp;gt; 협력에 참여하는 훌륭한 객체는 상태가 아니라 행동에 초점을 맞추는 것-&amp;gt; “행동이 상태를 결정한다.”" }, { "title": "객체지향의 5대원칙 - SOLID (SRP, OCP, LSP, ISP, DIP)", "url": "/posts/SOLID/", "categories": "Design Pattern", "tags": "SOLID, Design Pattern", "date": "2021-11-15 13:58:00 +0900", "snippet": "객체지향의 5대원칙 : SOLID (SRP, OCP, LSP, ISP, DIP)SOLID란 Robert C. Martin이 2000년대 초반에 명명한 객체 지향 프로그래밍 및 설계의 다섯가지 기본 원칙을 마이클 페더스가 두문자 기억술로 소개한 것이다.프로그래머가 시간이 지나도 유지보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다.SOLID 원칙들은 가독성이 좋고, 확장하기 쉽게 될 때까지, 리팩토링하기를 권장.→ 냄새나는 코드의 제거가 목표. 변화의 수용에 최적화!SRP - 단일 책임 원칙 (Single responsibility principle)단일 책임 원칙(single responsibility principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다. (함수나 모듈도 단일 책임을 위임해야함)여기서 책임이란, ‘기능’ 정도의 의미로 해석하면 된다.한 모듈에 책임이 많아진다면, 그 책임만큼 변화를 감당해야 할 수 있음.책임이 많아지면 클래스 내부의 함수끼리 강한 결합을 발생할 가능성이 높아진다. 이는 유지보수에 비용이 증가하게 되므로 따라서 책임을 분리시킬 필요가 있다.OCP - 개방-폐쇄 원칙 (Open/closed principle)개방-폐쇄 원칙(OCP, Open-Closed Principle)은 ‘소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다’는 원칙즉, 기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.OCP에 만족하는 설계를 할 때 변경되는 것이 무엇인지에 초점을 맞춘다. 자주 변경되는 내용은 수정하기 쉽게 설계 하고, 변경되지 않아야 하는 것은 수정되는 내용에 영향을 받지 않게 하는 것이 포인트class Player { void play(){ System.out.println(&quot;play youtube&quot;); // 유튜브 재생 } } public class Client { public static void main(String[] args) { Player player = new Player(); player.play(); } } Player 클래스는 영상을 재생해주는 클래스이다. 이 클래스는 기본적으로 youtube를 재생 할 수 있다. 그러나 player가 다른 서비스의 영상, 예를들어 Netflix의 영상을 재생하도록 요구사항이 변경 되었다고 하자. 요구사항 만족을 위해서는 Player의 play() 메소드 자체를 수정하여야 한다. 이러한 소스의 변경은 OCP 원칙에 위배된다.그렇다면 어떻게 해야 OCP 원칙을 만족시킬 수 있을까? 다양한 방법이 있지만 여기선 인터페이스를 이용하여 OCP를 만족시켜 보자. 먼저 변해야 하는것은 무엇인지 정의한다. 위 클래스에서는 play() 메소드가 변해야 하는 것이다. 따라서 play() 메소드를 인터페이스로 분리한다.interface PlayerType{ public void play(); } class Youtube implements PlayerType{ @Override public void play(){ System.out.println(&quot;play youtube&quot;); // 유튜브 재생 } } class Netflix implements PlayerType{ @Override public void play(){ System.out.println(&quot;play Netflix&quot;); // 넷플릭스 재생 } } class Player{ private PlayerType playerType; public void setPlayerType(PlayerType playerType) { this.playerType = playerType; } public void play() { playerType.play() }}public class Client { public static void main(String[] args) { player player = new Player(); player.setPlayerType(new Youtube()); //원하는 플랫폼 선택 player.setPlayerType(new Netflix()); player.play(); } } Player 클래스에서는 playerLogic 인터페이스를 멤버 변수로 만든다. 그 후 Player play() 함수는 인터페이스를 상속받아 구현된 클래스의 play()함수를 실행시키게 한다. 마지막으로 메인함수에서 setter를 이용하여 우리가 플레이하고자 하는 파일의 객체를 지정해주면 된다.결과적으로 player 클래스는 변경 없이 재생 플랫폼을 바꿀 수 있으므로 OCP를 만족한다. 하지만 클라이언트 코드는 변경이 필요하다. 수정에는 닫혀있어야 된다고 했지만! (반쪽짜리 OCP충족)→ 이 문제를 해결해기 위해서는 생성자를 통해 외부(AppConfig)에서 의존관계 주입으로 완전한 OCP를 충족시켜야한다!public class AppConfig() { public PlayerType playerType() { return new Youtube(); }}public class Client { public static void main(String[] args) { AppConfig appConfig = new AppConfig(); player player = new Player(); //player.setPlayerType(new Youtube()); //player.setPlayerType(new Netflix()); // 여전히 수정에 열려있음. player.setPlayerType(appConfig.playerType()); // AppConfig를 통한 기존코드 변경을 없앰. player.play(); } } LSP - 리스코프 치환 원칙 (Liskov substitution principle)자료형S가 자료형T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다. 이는 객체 지향 프로그래밍에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 한다는 것을 의미한다.이해를 돕기위해 도형을 예시를 들어보자. 도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스의 상속을 받는다고 가정하자.(1) 도형은 둘레를 가지고 있다. (2) 도형은 넓이를 가지고 있다. (3) 도형은 각을 가지고 있다. 일반화 관계(일관성인지 확인하는 방법은 단어를 교체해 보면 알 수 있다. (1) ~ (3)의 도형이란 단어 대신 사각형을 넣어보자.(1) 사각형은 둘레를 가지고 있다. (2) 사각형은 넓이를 가지고 있다. (3) 사각형은 각을 가지고 있다. (1) ~ (3) 모두 딱히 이상한 부분이 보이지 않는다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다.여기서 원(Circle) 이라는 도형에 대해 생각해보자. 원 클래스 역시 도형 클래스의 상속을 받는다고 가정하자. 앞에서 언급한 (1) ~ (3)의 도형 단어 대신 원을 대입해보자.(1) 원은 둘레를 가지고 있다.(2) 원은 넓이를 가지고 있다.(3) 원은 각을 가지고 있다.문장을 읽어보면 (3)번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP을 만족하지 않은 설계라 할 수 있다. 따라서 (3)문장에 대해서는 일반화 관계가 성립하도록 수정되어야 한다.[JAVA 객체 지향 디자인 패턴(정인상/채홍석 지음, 한빛미디어, 2014) p.116~117 예시참고]ISP - 인터페이스 분리 원칙 (Interface segregation principle)“특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”라는 원칙이다. 이는 다시 말해서, 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말아야 한다는 의미이다.예를들어, 우리가 노트북을 사용한다고 생각해보자. 인터넷을 하고 싶은사람과 게임을 하고 싶은사람, 동영상을 보고 싶은 사람은 노트북이 다양한 기능을 제공하고 있지만 본인이 원하는 기능만이 작동하면 되며 자신이 이용하지 않는 기능에 대해서는 영향을 받지 않는다. 이러한 기능을 제공하고 싶을 때 사용되는 것이 ISP이며 사용 방법은 범용의 인터페이스를 만드는 것이 아니라 클라이언트에 특화된 인터페이스를 사용해야한다. 즉 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이라고 할 수 있다.DIP - 의존관계 역전 원칙 (Dependency inversion principle)프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” (구현에 의존하면 안되고 역할에 의존해야함).의존이란 객체A가 객체B를 사용,포함 할 때 A가 B에 의존적이라고 할 수 있다.예를들면, 운전자는 자동차라는 역할 부분에 추상화하여 의존해야지 [아반떼, K5, 테슬라] 등의 구현체에 의존해서는 안된다.DIP를 만족하면 ‘의존성 주입’ 이라는 기술로 변화에 유연한 설계를 할 수 있다.class Player{ private PlayerType playerType; public void setPlayerType(PlayerType playerType) { this.playerType = playerType; } public void play() { playerType.play() }}public class Client { public static void main(String[] args) { player player = new Player(); player.setPlayerType(new Youtube()); //원하는 플랫폼 선택 player.setPlayerType(new Netflix()); player.play(); } } 우리는 setPlatform 클래스를 이용하여 실행하고자 하는 파일을 쉽게 바꿀 수 있다. 마찬가지로 새로운 플랫폼(디즈니플러스)을 실행시키고자 한다면, 새로운 클래스(disney)를 만든 후 play 인터페이스를 상속받아 구현한 후 setPlatform 메소드를 이용하여 platform 멤버 변수에 주입시키면 된다. 이와같은 기술을 ‘의존성 주입’ 이라 한다.하지만 OCP와 마찬가지로 여전히 클라이언트 코드에서는 new Youtube()와 new Netflix()같이 구체화된 클래스에 의존하게 되는데 이 문제를 해결해기 위해서는 생성자를 통해 외부(AppConfig)에서 의존관계 주입을 통한 관심사의 분리를 통해 완전한 DIP를 충족시켜야한다!public class AppConfig() { public PlayerLogic playerLogic() { return new Youtube(); }}public class Client { public static void main(String[] args) { AppConfig appConfig = new AppConfig(); player player = new Player(); //player.setPlayerType(new Youtube()); //player.setPlayerType(new Netflix()); // 여전히 구체화에 의존적 player.setPlayerType(appConfig.playerType()); // AppConfig를 통한 관심사 분리! player.play(); } } [참고자료] https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84) https://velog.io/@kyle/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-SOLID-%EC%9B%90%EC%B9%99-%EC%9D%B4%EB%9E%80 https://dev-momo.tistory.com/entry/SOLID-원칙 [JAVA 객체 지향 디자인 패턴(정인상/채홍석 지음, 한빛미디어, 2014)]" }, { "title": "[JPA] 상속관계 매핑, @MappedSuperclass", "url": "/posts/JPA8/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-11-09 15:02:00 +0900", "snippet": "[JPA] 상속관계 매핑, @MappedSuperclass- 관계형 데이터베이스는 상속관계가 없다- 슈퍼타입, 서브타입 관계라는 모델링 기법이 객체 상속과 유사- 상속관계 매핑 : 객체의 상속구조와 DB의 슈퍼타입, 서브타입 관계를 매핑슈퍼타입, 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법 각각 테이블로 변환 -&amp;gt; 조인 전략 통합 테이블로 변환 -&amp;gt; 단일 테이블 전략 서브타입 테이블로 변환 -&amp;gt; 구현 클래스마다 테이블 전략 @Inheritance(strategy=InheritanceType.XXX) JOINED: 조인 전략 SINGLE_TABLE: 단일 테이블 전략 TABLE_PER_CLASS: 구현 클래스마다 테이블 전략 @DiscriminatorColumn(name=“DTYPE”) @DiscriminatorValue(“XXX”)조인전략 - @Inheritance(strategy=InheritanceType.JOINED)• 장점 - 테이블 정규화 - 외래 키 참조 무결성 제약조건 활용가능 - 저장공간 효율화• 단점 - 조회시 조인을 많이 사용, 성능 저하 - 조회 쿼리가 복잡함 - 데이터 저장시 INSERT SQL 2번 호출단일 테이블 전략 - @Inheritance(strategy=InheritanceType.SINGLE_TABLE)• 장점 - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름 - 조회 쿼리가 단순함• 단점 - 자식 엔티티가 매핑한 컬럼은 모두 null 허용 - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. - 상황에 따라서 조회 성능이 오히려 느려질 수 있다.구현 클래스마다 테이블 전략 - @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)• 장점 - 서브 타입을 명확하게 구분해서 처리할 때 효과적 - not null 제약조건 사용 가능• 단점 - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요) - 자식 테이블을 통합해서 쿼리하기 어려움@MappedSuperclass- 공통 매핑 정보가 필요할 때 사용(id, name)- 상속관계 매핑X- 엔티티X, 테이블과 매핑X- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공- 조회, 검색 불가(em.find(BaseEntity) 불가)- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용- 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] 연관관계 매핑의 종류(@ManyToOne, @OneToMany, @OneToOne, @ManyToMany)", "url": "/posts/JPA7/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-11-09 14:05:00 +0900", "snippet": "다양한 연관관계 매핑연관관계 매핑시 고려사항 3가지- 다중성 다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany- 단방향, 양방향 테이블 외래키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 - 연관관계의 주인 테이블은 외래키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A-&amp;gt;B, B-&amp;gt;A처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래키를 관리할 곳을 지정해야함 연관관계의 주인 : 외래키를 관리하는 참조 주인의 반대편 : 외래키에 영향을 주지 않음, 단순 조회만 가능 외래키가 있는 곳을 연관관계의 주인으로 설정!◆ 다대일 [N:1] - @ManyToOne- 다대일 단방향 가장 많이 사용하는 연관관계 다대일의 반대는 일대다- 다대일 양방향 외래키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발◆ 일대다 [1:N] - @OneToMany- 일대다 단방향 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조 @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함) 일대다 단방향 매핑의 단점 엔티티가 관리하는 외래 키가 다른 테이블에 있음 연관관계 관리를 위해 추가로 UPDATE SQL 실행 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하도록 권장- 일대다 양방향 이런 매핑은 공식적으로 존재안함 @JoinColumn(insertable=false, updatable=false) 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 다대일 양방향을 사용 권장◆ 일대일 [1:1] - @OneToOne 일대일 관계는 그 반대도 일대일 주 테이블이나 대상 테이블 중에 외래 키 선택 가능 주 테이블에 외래키 대상 테이블에 외래키 외래키에 데이터베이스 유니크(UNI) 제약조건 추가- 주 테이블에 외래키 단방향 다대일(@ManyToOne) 단방향 매핑과 유사- 주 테이블에 외래키 양방향 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인 반대편은 mappedBy 적용- 대상 테이블에 외래키 단방향 단방향 관계는 JPA 지원X - 대상 테이블에 외래키 양방향 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음 주 테이블에 외래 키 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자 선호 JPA 매핑 편리 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점: 값이 없으면 외래 키에 null 허용 대상 테이블에 외래 키 대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자 선호 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 ◆ 다대다 [N:N] - @ManyToMany 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음 연결 테이블을 추가해서 일대다, 다대일 관계로 표현해야함 @JoinTable로 연결 테이블용 엔티티 추가 (연결 테이블을 엔티티로 승격) 실무에서 사용X @ManyToMany를 @OneToMany, @ManyToOne으로 쪼개서 사용하는게 바람직(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] 단방향 연관관계, 양방향 연관관계", "url": "/posts/JPA6/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-10-13 14:05:00 +0900", "snippet": "연관관계 매핑 기본단방향 연관관계객체 연관관계 매핑객체의 참조와 테이블의 외래키를 매핑@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = &quot;USERNAME&quot;) private String name; private int age; // @Column(name = &quot;TEAM_ID&quot;) // private Long teamId; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; …연관관계 저장//팀 저장Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);//회원 저장Member member = new Member();member.setName(&quot;member1&quot;);member.setTeam(team); //단방향 연관관계 설정, 참조 저장em.persist(member);연관관계 조회(객체그래프 탐색)//조회Member findMember = em.find(Member.class, member.getId());//참조를 사용해서 연관관계 조회Team findTeam = findMember.getTeam();연관관계 수정// 새로운 팀BTeam teamB = new Team();teamB.setName(&quot;TeamB&quot;);em.persist(teamB);// 회원1에 새로운 팀B 설정member.setTeam(teamB);양방향 연관관계양방향 매핑 (Member-Team) Member 엔티티는 단방향과 동일 @Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = &quot;USERNAME&quot;) private String name; private int age; // @Column(name = &quot;TEAM_ID&quot;) // private Long teamId; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; … Team 엔티티는 컬렉션 추가 @Entitypublic class Team { @Id @GeneratedValue private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;Member&amp;gt;(); …} 반대 방향으로 그래프 탐색//조회Team findTeam = em.find(Team.class, team.getId());int memberSize = findTeam.getMembers().size(); //역방향 조회 객체와 테이블이 관계를 맺는 차이 객체 연관관계 = 2개 회원 -&amp;gt; 팀 연관관계 1개(단방향) 팀 -&amp;gt; 회원 연관관계 1개(단방향) 테이블 연관관계 = 1개 회원&amp;lt;-&amp;gt;팀의 연관관계 1개(양방향) 객체의 양방향은 서로 다른 단방향관계 2개로 이루어진다. 테이블은 외래키 하나로 두 테이블의 연관관계를 관리SELECT *FROM MEMBER MJOIN TEAM T ON M.TEAM_ID = T.TEAM_IDSELECT *FROM TEAM TJOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID 둘 중 하나의 엔티티에서 외래키를 관리해야함연관관계의 주인양방향 매핑 규칙 객체의 두 관계중 하나를 연관관계의 주인으로 지정 연관관계의 주인만이 외래키를 관리(등록, 수정) 주인이 아닌쪽은 읽기만 가능 주인은 mappedBy 속성 사용x 주인이 아니면 mappedBy 속성으로 주인이 아니라는것을 지정 외래키가 있는 곳을 주인으로 지정 양방향 매핑시 순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야함.Team team = new Team();team.setName(&quot;TeamA&quot;);em.persist(team);Member member = new Member();member.setName(&quot;member1&quot;);team.getMembers().add(member);//연관관계의 주인에도 값 설정member.setTeam(team); //**em.persist(member); 양방향 매핑 정리 단방향 매핑만으로도 이미 연관관계 매핑은 완료 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐 JPQL에서 역방향으로 탐색할 일이 많음 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨 (테이블에 영향을 주지 않음) 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨 (무조건 외래키가 있는쪽으로 주인설정) 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] 엔티티 매핑 - 2 (기본키 매핑, 기본키 자동생성 전략)", "url": "/posts/JPA5/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-10-08 17:05:00 +0900", "snippet": "엔티티 매핑 - 2 (기본키 매핑, 기본키 자동생성 전략)기본키 매핑 어노테이션 @Id @GeneratedValue @Id @GeneratedValue(strategy = GenerationType.AUTO)private Long id; 기본 키 매핑 방법 직접 할당 : @Id만 사용 자동 생성(@GeneratedValue) IDENTITY : 데이터베이스에 위임, MYSQL SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE - @SequenceGenerator 필요 TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용 - @TableGenerator 필요 AUTO : 방언에 따라 자동 지정, 기본값IDENTITY 전략 기본 키 생성을 데이터베이스에 위임 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용 (예: MySQL의 AUTO_ INCREMENT) JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행 AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음 IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자를 조회 @Entitypublic class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; } SEQUENCE 전략 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트(예: 오라클 시퀀스) 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용 @Entity@SequenceGenerator( name = “MEMBER_SEQ_GENERATOR&quot;, sequenceName = “MEMBER_SEQ&quot;, //매핑할 데이터베이스 시퀀스 이름 initialValue = 1, allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;MEMBER_SEQ_GENERATOR&quot;) private Long id; @SequenceGenerator 주의: allocationSize 기본값 = 50 속성 설명 기본값 name 식별자 생성기 이름 필수 sequenceName 데이터베이스에 등록되어 있는 시퀀스 이름 hibernate_sequence initialValue DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 1 시작하는수를 지정한다. 1 allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨) 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다 50 catalog, schema 데이터베이스 catalog, schema 이름   TABLE 전략 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략 장점: 모든 데이터베이스에 적용 가능 단점: 성능이 안좋음create table MY_SEQUENCES ( sequence_name varchar(255) not null, next_val bigint, primary key ( sequence_name ))@Entity@TableGenerator( name = &quot;MEMBER_SEQ_GENERATOR&quot;, table = &quot;MY_SEQUENCES&quot;, pkColumnValue = “MEMBER_SEQ&quot;, allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;MEMBER_SEQ_GENERATOR&quot;) private Long id; (출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] 엔티티 매핑 - 1 (매핑 어노테이션 정리)", "url": "/posts/JPA4/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-10-08 16:20:00 +0900", "snippet": "엔티티 매핑 - 1 (매핑 어노테이션 정리)@Entity @Entity가 붙은 클래스는 JPA가 관리, 엔티티라고 함 JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 기본 생성자 필수 (파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용불가 저장할 필드에 final 사용불가 속성 name JPA에서 사용할 엔티티 이름을 지정한다. 기본값 : 클래스 이름을 그대로 사용(예: Member) 같은 클래스 이름이 없으면 가급적 기본값을 사용 @Table - 엔티티와 매핑할 테이블 지정 속성 기능 기본값 name 매핑할 테이블 이름 엔티티 이름을 사용 catalog 데이터베이스 catalog매핑   schema 데이터베이스 schema 매핑   uniqueConstraints (DDL) DDL 생성시에 유니크 제약조건 생성   데이터베이스 스키마 자동생성 DDL을 애플리케이션 실행 시점에 자동생성 테이블 중심 -&amp;gt; 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 DDL생성 생성된 DDL은 개발장비에서만 사용 생성된 DDL은 운영서버에서는 사용하지 않거나 적절히 다듬은 후 사용권장 속성 (hibernate.hbm2ddl.auto) 옵션 설명 create 기존테이블 삭제 후 다시 생성 (DROP + CREATE) create-drop create와 같으나 종료시점에 테이블 DROP update 변경분만 반영(운영DB에는 사용하면 안됨) validate 엔티티와 테이블이 정상 매핑되었는지만 확인 none 사용하지 않음 제약조건 추가: 회원 이름은 필수, 10자 초과X @Column(nullable = false, length = 10) 유니크 제약조건 추가 @Table(uniqueConstraints = {@UniqueConstraint( name = &quot;NAME_AGE_UNIQUE&quot;, columnNames = {&quot;NAME&quot;, &quot;AGE&quot;} )}) 매핑 어노테이션 정리 어노테이션 설명 @Column 컬럼 매핑 @Temporal 날짜 타입 매핑 @Enumerated enum 타입 매핑 @Lob BLOB, CLOB 매핑 @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시) @Column 속성 설명 기본값 name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름   insertable,updatable 등록, 변경 가능 여부 TRUE   nullable(DDL) null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.   unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다.   columnDefinition (DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다.ex) varchar(100) default ‘EMPTY’ 필드의 자바 타입과 방언 정보를 사용해서 적절한 컬럼 타입 length(DDL) 문자 길이 제약조건, String 타입에만 사용한다. 255 precision, scale(DDL) BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다).precision은 소수점을 포함한 전체 자 릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나정 밀한 소수를 다루어야 할 때만 사용한다. precision=19, scale=2 @Enumerated - 자바 enum 타입을 매핑할 때 사용 주의! ORDINAL 사용X 속성 설명 기본값 value • EnumType.ORDINAL: enum 순서를 데이터베이스에 저장 • EnumType.STRING: enum 이름을 데이터베이스에 저장 EnumType.ORDINAL @Temporal 날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용 참고: LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원) 속성 설명 기본값 value • TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11)• TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11: 11: 11)• TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11: 11: 11)   @Lob 데이터베이스 BLOB, CLOB 타입과 매핑 @Lob에는 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑 CLOB: String, char[], java.sql.CLOB BLOB: byte[], java.sql. BLOB @Transient 필드 매핑X 데이터베이스에 저장X, 조회X 주로 메모리상에서만 임시로 어떤 값을 보관하고 싶을 때 사용 @Transientprivate Integer temp; (출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] 영속성 관리", "url": "/posts/JPA3/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-10-06 15:09:00 +0900", "snippet": "영속성 관리엔티티 매니저 팩토리와 엔티티 매니저영속성 컨텍스트 JPA를 이해하는데 가장 중요한 용어 “엔티티를 영구 저장하는 환경”이라는 뜻 EntityManager.persist(entity); 영속성 컨텍스트는 논리적인 개념 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근엔티티의 생명주기 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속(managed) : 영속성 컨텍스트에 관리되는 상태 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed) : 삭제된 상태비영속Member member = new Member(); member.setId(&quot;member1&quot;); member.setUsername(&quot;회원1&quot;); 영속//객체를 생성한 상태(비영속)Member member = new Member(); member.setId(&quot;member1&quot;); member.setUsername(&quot;회원1&quot;); EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); //객체를 저장한 상태(영속) em.persist(member); 준영속, 삭제//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태 em.detach(member); //객체를 삭제한 상태(삭제) em.remove(member); 영속성 컨텍스트의 이점 1차 캐시 //1차 캐시에 저장됨 em.persist(member); //1차 캐시에서 조회 Member findMember = em.find(Member.class, &quot;member1&quot;); 1차캐시에 없을시 데이터베이스에서 조회 동일성 보장 Member a = em.find(Member.class, &quot;member1&quot;); Member b = em.find(Member.class, &quot;member1&quot;); System.out.println(a == b); //동일성 비교 true 트랜잭션을 지원하는 쓰기 지연 transaction.begin() : 트랜잭션 시작, transaction.commit(); 트랜잭션 커밋 커밋하기 전까지 데이터베이스에 보내지 않는다. 변경 감지 지연 로딩플러시 영속성 컨텍스트의 변경내용을 데이터베이스에 반영 플러시 발생시, 변경감지,수정된 엔티티 쓰기 지연 SQL 저장소에 등록, 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리) 영속성 컨텍스트를 비우지 않음 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 트랜잭션이라는 작업 단위가 중요 -&amp;gt; 커밋 직전에만 동기화 하면 됨영속성 컨텍스트를 플러시하는 방법 em.flush() - 직접 호출 트랜잭션 커킷 - 플러시 자동호출 JPQL 쿼리 실행 - 플러시 자동호출플러시 모드 옵션em.setFlushMode(FlushModeType.COMMIT) FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (기본값) FlushModeType.COMMIT : 커밋할 때만 플러시준영속 상태 영속 -&amp;gt; 준영속 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 영속성 컨텍스트가 제공하는 기능을 사용 못함 em.detach(entity) - 특정 엔티티만 준영속 상태로 전환 em.clear() - 영속성 컨텍스트를 완전히 초기화 em.close() - 영속성 컨텍스트를 종료(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] JPA 시작하기", "url": "/posts/JPA2/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-09-13 14:00:00 +0900", "snippet": "JPA시작하기라이브러리 추가 - pom.xml&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;jpa-basic&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ex1-hello-jpa&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- JPA 하이버네이트 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-entitymanager&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.10.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- H2 데이터베이스 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.199&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;JPA 설정하기 - persistence.xml JPA 설정 파일 /META-INF/persistence.xml 위치 persistence-unit name으로 이름 지정 javax.persistence로 시작: JPA 표준 속성 hibernate로 시작: 하이버네이트 전용 속성&amp;lt;persistence-unit name=&quot;hello&quot;&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;!-- 필수 속성 --&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;org.h2.Driver&quot;/&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;sa&quot;/&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;&quot;/&amp;gt; &amp;lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:h2:tcp://localhost/~/test&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&amp;gt; &amp;lt;!-- 옵션 --&amp;gt; &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;true&quot;/&amp;gt; &amp;lt;!--&amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&amp;gt;--&amp;gt; &amp;lt;/properties&amp;gt;&amp;lt;/persistence-unit&amp;gt;데이터베이스 방언 JPA는 특정 데이터베이스에 종속 X 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름 가변 문자: MySQL은 VARCHAR, Oracle은 VARCHAR2 문자열을 자르는 함수: SQL 표준은 SUBSTRING(), Oracle은 SUBSTR() 페이징: MySQL은 LIMIT , Oracle은 ROWNUM 방언: SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능 hibernate.dialect 속성에 지정 H2 : org.hibernate.dialect.H2Dialect Oracle 10g : org.hibernate.dialect.Oracle10gDialect MySQL : org.hibernate.dialect.MySQL5InnoDBDialect 하이버네이트는 40가지 이상의 데이터베이스 방언 지원 JPA 구동방식객체와 테이블을 생성하고 매핑하기@Entity: JPA가 관리할 객체 @Id: 데이터베이스 PK와 매핑 package hellojpa; import javax.persistence.Entity; import javax.persistence.Id; @Entitypublic class Member { @Id private Long id; private String name; //Getter, Setter … } create table Member ( id bigint not null, name varchar(255), primary key (id) ); (출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "[JPA] JPA란?", "url": "/posts/JPA1/", "categories": "JPA", "tags": "JPA, ORM, Hibernate", "date": "2021-09-13 11:50:00 +0900", "snippet": "JPA란?JPA Java Persistence API 자바 진영의 ORM 기술 표준ORM Object-relational mapping(객체 관계 매핑) 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설계 ORM 프레임워크가 중간에서 매핑 대중적인 언어에는 대부분 ORM 기술이 존재JPA의 동작과정JPA는 애플리케이션과 JDBC 사이에서 동작저장조회JPA 표준명세 JPA는 인터페이스의 모음 JPA 2.1 표준 명세를 구현한 3가지 구현체 하이버네이트, EclipseLink, DataNucleusJPA 버전 JPA 1.0(JSR 220) 2006년 : 초기 버전. 복합 키와 연관관계 기능이 부족 JPA 2.0(JSR 317) 2009년 : 대부분의 ORM 기능을 포함, JPA Criteria 추가 JPA 2.1(JSR 338) 2013년 : 스토어드 프로시저 접근, 컨버터(Converter), 엔티티 그래프 기능이 추가JPA를 왜 사용해야 하는가? SQL 중심적인 개발에서 객체 중심으로 개발 생산성 유지보수 패러다임의 불일치 해결 성능 데이터 접근 추상화와 벤더 독립성 표준* 유지보수기존 : 필드 변경시 모든 SQL 수정JPA : 필드만 추가하면 됨, SQL은 JPA가 처리* 패러다임의 불일치 해결1. JPA와 상속2. JPA와 연관관계, 객체 그래프 탐색// 연관관계 저장 member.setTeam(team); jpa.persist(member); // 객체 그래프 탐색 Member member = jpa.find(Member.class, memberId); Team team = member.getTeam(); // 신뢰할 수 있는 엔티티, 계층 class MemberService { ... public void process() { Member member = memberDAO.find(memberId); member.getTeam(); //자유로운 객체 그래프 탐색 member.getOrder().getDelivery(); } } 3. JPA와 비교하기String memberId = &quot;100&quot;; Member member1 = jpa.find(Member.class, memberId); Member member2 = jpa.find(Member.class, memberId); member1 == member2; //같다. 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장* JPA의 성능 최적화 기능 1차 캐시와 동일성(identity) 보장 같은 트랜젝션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상 DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장 String memberId = &quot;100&quot;;Member m1 = jpa.find(Member.class, memberId); //SQLMember m2 = jpa.find(Member.class, memberId); //캐시println(m1 == m2) //true //1번만 실행 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) INSERT 트랜잭션을 커밋할 때까지 INSERT SQL을 모음 JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송 transaction.begin(); // [트랜잭션] 시작 em.persist(memberA); em.persist(memberB); em.persist(memberC); //여기까지 INSERT SQL을 데이터베이스에 보내지 않는다. //커밋하는 순간 데이터베이스에 INSERT SQL을 모아서 보낸다. transaction.commit(); // [트랜잭션] 커밋 UPDATE UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고, 바로 커밋 transaction.begin(); // [트랜잭션] 시작 changeMember(memberA); deleteMember(memberB); 비즈니스_로직_수행(); //비즈니스 로직 수행 동안 DB 로우 락이 걸리지 않는다. //커밋하는 순간 데이터베이스에 UPDATE, DELETE SQL을 보낸다. transaction.commit(); // [트랜잭션] 커밋 지연 로딩과 즉시로딩 지연 로딩: 객체가 실제 사용될 때 로딩 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회 (출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)" }, { "title": "마크다운이란?", "url": "/posts/Markdown/", "categories": "Blogging, Tutorial", "tags": "google analytics, pageviews", "date": "2021-09-12 19:13:00 +0900", "snippet": "1. 마크다운이란?일반 텍스트 문서의 양식을 편집하는 문법, README 파일이나 온라인 문서, 혹은 일반 텍스트 편집기로 문서 양식을 편집할 때 쓰인다. 마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서형태로 변환이 가능2. 기본문법※ 개행: 스페이스 2개 + 엔터※ 문단구분: 엔터 2번 제목 # 텍스트 #을 하나 쓰면 HTML의 &amp;lt;h1&amp;gt; 태그를, #을 두개 쓰면 &amp;lt;h2&amp;gt;태그를 의미한다. 즉, #은 하나에서 여섯개까지 쓸 수 있고, #이 늘어날때마다 제목의 수준은 내려간다.(보통 글씨 크기가 작아진다.) 번호 없는 리스트 -/+/* 텍스트 번호 있는 리스트 숫자. 리스트 기울인 글씨 (html의 태그) *텍스트* or _텍스트_ 굵은 글씨 (html의 태그) **텍스트** or __텍스트__ 인용 &amp;gt; 텍스트 인용문안에 인용문을 넣으려면 &amp;gt;를 더 추가해주면 된다. 인라인 링크 [텍스트](링크주소) 참조 링크 [텍스트][참조명][참조명]: 링크주소 이미지 ![텍스트](이미지링크) 수평선 -, *, _을 세개 이상 나열 코드(인라인) `코드 내용` 코드(블록) 앞에 스페이스 4개 이상 삽입 3. 에디터MarkdownPad2 을 추천한다. 무료다. 왼쪽에는 마크다운을, 오른쪽에는 프리뷰를 제공해준다. window10에서 프리뷰 에러 이슈가 있는데, 공식홈페이지 트러블슈팅가이드에서 Awesomium 1.6.6 SDK를 다운로드받으면 해결된다." } ]
