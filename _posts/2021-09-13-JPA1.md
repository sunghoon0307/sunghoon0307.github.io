---
title: "[JPA] JPA란?"
author: sunghoon
date: 2021-09-13 11:50:00 +0900
categories: [JPA]
tags: [JPA, ORM, Hibernate]
pin: false
--- 


# JPA란?  
---

## JPA  
- Java Persistence API
- 자바 진영의 ORM 기술 표준  

  
## ORM
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재  
  
## JPA의 동작과정  
### JPA는 애플리케이션과 JDBC 사이에서 동작  
![사진1](/assets/img/JPA_1/JPA_1_1.jpg)  

### 저장  
![사진2](/assets/img/JPA_1/JPA_1_2.jpg)  

### 조회  
![사진3](/assets/img/JPA_1/JPA_1_3.jpg)  

## JPA 표준명세
- JPA는 인터페이스의 모음
- JPA 2.1 표준 명세를 구현한 3가지 구현체
- 하이버네이트, EclipseLink, DataNucleus  
![사진4](/assets/img/JPA_1/JPA_1_4.jpg)  
  
## JPA 버전
- JPA 1.0(JSR 220) 2006년 : 초기 버전. 복합 키와 연관관계 기능이 부족
- JPA 2.0(JSR 317) 2009년 : 대부분의 ORM 기능을 포함, JPA Criteria 추가
- JPA 2.1(JSR 338) 2013년 : 스토어드 프로시저 접근, 컨버터(Converter), 엔티
티 그래프 기능이 추가  

## JPA를 왜 사용해야 하는가?
- SQL 중심적인 개발에서 객체 중심으로 개발
- 생산성
- 유지보수
- 패러다임의 불일치 해결
- 성능
- 데이터 접근 추상화와 벤더 독립성
- 표준  

### * 유지보수
#### 기존 : 필드 변경시 모든 SQL 수정  
![사진5](/assets/img/JPA_1/JPA_1_5.jpg)  
 
#### JPA : 필드만 추가하면 됨, SQL은 JPA가 처리  
![사진6](/assets/img/JPA_1/JPA_1_6.jpg)  
 
### * 패러다임의 불일치 해결  
#### 1. JPA와 상속  
![사진7](/assets/img/JPA_1/JPA_1_7.jpg)  

#### 2. JPA와 연관관계, 객체 그래프 탐색 
  
```java  
// 연관관계 저장  
member.setTeam(team);  
jpa.persist(member);  
  
// 객체 그래프 탐색  
Member member = jpa.find(Member.class, memberId);  
Team team = member.getTeam();  
  
// 신뢰할 수 있는 엔티티, 계층  
class MemberService {  
	...  
	public void process() {  
		Member member = memberDAO.find(memberId);  
		member.getTeam(); //자유로운 객체 그래프 탐색  
		member.getOrder().getDelivery();  
	}  
}  
```    

#### 3. JPA와 비교하기 
```java  
String memberId = "100";  
Member member1 = jpa.find(Member.class, memberId);  
Member member2 = jpa.find(Member.class, memberId);  
member1 == member2; //같다.  
``` 
동일한 트랜잭션에서 조회한 엔티티는 같음을 보장  

### * JPA의 성능 최적화 기능  
- 1차 캐시와 동일성(identity) 보장  
	* 같은 트랜젝션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상  
	*  DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장  
```java  
String memberId = "100";
Member m1 = jpa.find(Member.class, memberId); //SQL
Member m2 = jpa.find(Member.class, memberId); //캐시
println(m1 == m2) //true 
//1번만 실행
```  

- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
	- INSERT
		* 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
		* JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
		```java
		transaction.begin(); // [트랜잭션] 시작
		em.persist(memberA);
		em.persist(memberB);
		em.persist(memberC);
		//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.
		//커밋하는 순간 데이터베이스에 INSERT SQL을 모아서 보낸다.
		transaction.commit(); // [트랜잭션] 커밋
		```  
	- UPDATE
		* UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화  
		* 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고, 바로 커밋  
		```java  
		transaction.begin(); // [트랜잭션] 시작  
		changeMember(memberA);  
		deleteMember(memberB);  
		비즈니스_로직_수행(); //비즈니스 로직 수행 동안 DB 로우 락이 걸리지 않는다.  
		//커밋하는 순간 데이터베이스에 UPDATE, DELETE SQL을 보낸다.  
		transaction.commit(); // [트랜잭션] 커밋  
		```  

- 지연 로딩과 즉시로딩
	* 지연 로딩: 객체가 실제 사용될 때 로딩
	* 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회
	![사진8](/assets/img/JPA_1/JPA_1_8.jpg) 

(출처 : 자바 ORM 표준 JPA 프로그래밍 - 김영한 저)  
![출처책표지](/assets/img/JPA_book.jpg)